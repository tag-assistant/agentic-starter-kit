name: Agentic Release Notes

on:
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g., v1.0.0)"
        required: true
      previous_tag:
        description: "Previous release tag (auto-detected if empty)"
        required: false

permissions:
  contents: write
  pull-requests: read

jobs:
  generate-notes:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine tags
        id: tags
        env:
          INPUT_TAG: ${{ github.event.inputs.tag }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
        run: |
          TAG="${INPUT_TAG:-$RELEASE_TAG}"
          echo "current=$TAG" >> "$GITHUB_OUTPUT"

          # Find previous tag
          PREV="${{ github.event.inputs.previous_tag }}"
          if [ -z "$PREV" ]; then
            PREV=$(git tag --sort=-version:refname | grep -A1 "^$TAG$" | tail -1)
          fi
          echo "previous=$PREV" >> "$GITHUB_OUTPUT"

      - name: Generate release notes
        uses: actions/github-script@v7
        env:
          CURRENT_TAG: ${{ steps.tags.outputs.current }}
          PREVIOUS_TAG: ${{ steps.tags.outputs.previous }}
        with:
          script: |
            const currentTag = process.env.CURRENT_TAG;
            const previousTag = process.env.PREVIOUS_TAG;

            if (!currentTag) {
              core.setFailed('No current tag found');
              return;
            }

            // Get merged PRs between tags
            const compare = previousTag
              ? await github.rest.repos.compareCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  base: previousTag,
                  head: currentTag,
                })
              : null;

            // Get associated PRs
            const commits = compare?.data.commits || [];
            const prNumbers = new Set();
            for (const commit of commits) {
              const match = commit.commit.message.match(/#(\d+)/g);
              if (match) match.forEach(m => prNumbers.add(parseInt(m.slice(1))));
            }

            // Categorize PRs
            const categories = {
              'ðŸš€ Features': [],
              'ðŸ› Bug Fixes': [],
              'ðŸ“– Documentation': [],
              'ðŸ”§ Maintenance': [],
              'ðŸ”’ Security': [],
            };

            for (const num of prNumbers) {
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: num,
                });

                if (pr.state !== 'closed' || !pr.merged_at) continue;

                const labels = pr.labels.map(l => l.name);
                const entry = `- ${pr.title} (#${num}) @${pr.user.login}`;

                if (labels.includes('bug')) categories['ðŸ› Bug Fixes'].push(entry);
                else if (labels.includes('security')) categories['ðŸ”’ Security'].push(entry);
                else if (labels.includes('documentation')) categories['ðŸ“– Documentation'].push(entry);
                else if (labels.includes('enhancement') || labels.includes('feature'))
                  categories['ðŸš€ Features'].push(entry);
                else categories['ðŸ”§ Maintenance'].push(entry);
              } catch {
                // PR not found, skip
              }
            }

            // Build release notes
            const sections = Object.entries(categories)
              .filter(([, items]) => items.length > 0)
              .map(([title, items]) => `## ${title}\n\n${items.join('\n')}`)
              .join('\n\n');

            const range = previousTag ? `${previousTag}...${currentTag}` : currentTag;
            const notes = [
              sections || '_No categorized changes found._',
              '',
              '---',
              '',
              `**Full Changelog:** [\`${range}\`](https://github.com/${context.repo.owner}/${context.repo.repo}/compare/${range})`,
              '',
              `> ðŸ¤– Generated by [agentic-starter-kit](https://github.com/tag-assistant/agentic-starter-kit)`,
            ].join('\n');

            // Update release body if triggered by release event
            if (context.eventName === 'release') {
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: context.payload.release.id,
                body: notes,
              });
              core.info('Updated release notes');
            }

            core.info(notes);
            core.setOutput('notes', notes);
